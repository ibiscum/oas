/*
Polymorphism support

https://github.com/OAI/OpenAPI-Specification/blob/master/versions/3.0.3.md#schema-object

API version: 1.0.0
Contact: a-team@goarmy.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package polymorphism

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
)


// PetsAPIService PetsAPI service
type PetsAPIService service

type ApiAnyOfWithTypeRequest struct {
	ctx context.Context
	ApiService *PetsAPIService
	anyOfWithTypeRequest *AnyOfWithTypeRequest
}

func (r ApiAnyOfWithTypeRequest) AnyOfWithTypeRequest(anyOfWithTypeRequest AnyOfWithTypeRequest) ApiAnyOfWithTypeRequest {
	r.anyOfWithTypeRequest = &anyOfWithTypeRequest
	return r
}

func (r ApiAnyOfWithTypeRequest) Execute() (*http.Response, error) {
	return r.ApiService.AnyOfWithTypeExecute(r)
}

/*
AnyOfWithType anyOf With Type

AnyOf's with a top level type parameter should not render that type outside of their options

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAnyOfWithTypeRequest
*/
func (a *PetsAPIService) AnyOfWithType(ctx context.Context) ApiAnyOfWithTypeRequest {
	return ApiAnyOfWithTypeRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *PetsAPIService) AnyOfWithTypeExecute(r ApiAnyOfWithTypeRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PetsAPIService.AnyOfWithType")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/any-of-with-type"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.anyOfWithTypeRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAnythingAllOfObjectRequest struct {
	ctx context.Context
	ApiService *PetsAPIService
	anythingAllOfObjectRequest *AnythingAllOfObjectRequest
}

func (r ApiAnythingAllOfObjectRequest) AnythingAllOfObjectRequest(anythingAllOfObjectRequest AnythingAllOfObjectRequest) ApiAnythingAllOfObjectRequest {
	r.anythingAllOfObjectRequest = &anythingAllOfObjectRequest
	return r
}

func (r ApiAnythingAllOfObjectRequest) Execute() (*http.Response, error) {
	return r.ApiService.AnythingAllOfObjectExecute(r)
}

/*
AnythingAllOfObject allOf with listed objects

allOf with listed objects

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAnythingAllOfObjectRequest
*/
func (a *PetsAPIService) AnythingAllOfObject(ctx context.Context) ApiAnythingAllOfObjectRequest {
	return ApiAnythingAllOfObjectRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *PetsAPIService) AnythingAllOfObjectExecute(r ApiAnythingAllOfObjectRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PetsAPIService.AnythingAllOfObject")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/anything/all-of-object"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.anythingAllOfObjectRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAnythingAnyOfObjectRequest struct {
	ctx context.Context
	ApiService *PetsAPIService
	anythingAnyOfObjectRequest *AnythingAnyOfObjectRequest
}

func (r ApiAnythingAnyOfObjectRequest) AnythingAnyOfObjectRequest(anythingAnyOfObjectRequest AnythingAnyOfObjectRequest) ApiAnythingAnyOfObjectRequest {
	r.anythingAnyOfObjectRequest = &anythingAnyOfObjectRequest
	return r
}

func (r ApiAnythingAnyOfObjectRequest) Execute() (*http.Response, error) {
	return r.ApiService.AnythingAnyOfObjectExecute(r)
}

/*
AnythingAnyOfObject anyOf object

anyOf object

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAnythingAnyOfObjectRequest
*/
func (a *PetsAPIService) AnythingAnyOfObject(ctx context.Context) ApiAnythingAnyOfObjectRequest {
	return ApiAnythingAnyOfObjectRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *PetsAPIService) AnythingAnyOfObjectExecute(r ApiAnythingAnyOfObjectRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PetsAPIService.AnythingAnyOfObject")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/anything/any-of-object"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.anythingAnyOfObjectRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAnythingAnyOfPrimitiveRequest struct {
	ctx context.Context
	ApiService *PetsAPIService
	anythingAnyOfPrimitiveRequest *AnythingAnyOfPrimitiveRequest
}

func (r ApiAnythingAnyOfPrimitiveRequest) AnythingAnyOfPrimitiveRequest(anythingAnyOfPrimitiveRequest AnythingAnyOfPrimitiveRequest) ApiAnythingAnyOfPrimitiveRequest {
	r.anythingAnyOfPrimitiveRequest = &anythingAnyOfPrimitiveRequest
	return r
}

func (r ApiAnythingAnyOfPrimitiveRequest) Execute() (*http.Response, error) {
	return r.ApiService.AnythingAnyOfPrimitiveExecute(r)
}

/*
AnythingAnyOfPrimitive anyOf primitive

description

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAnythingAnyOfPrimitiveRequest
*/
func (a *PetsAPIService) AnythingAnyOfPrimitive(ctx context.Context) ApiAnythingAnyOfPrimitiveRequest {
	return ApiAnythingAnyOfPrimitiveRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *PetsAPIService) AnythingAnyOfPrimitiveExecute(r ApiAnythingAnyOfPrimitiveRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PetsAPIService.AnythingAnyOfPrimitive")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/anything/any-of-primitive"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.anythingAnyOfPrimitiveRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAnythingNestedOneOfObjectRefRequest struct {
	ctx context.Context
	ApiService *PetsAPIService
	anythingNestedOneOfObjectRefRequest *AnythingNestedOneOfObjectRefRequest
}

func (r ApiAnythingNestedOneOfObjectRefRequest) AnythingNestedOneOfObjectRefRequest(anythingNestedOneOfObjectRefRequest AnythingNestedOneOfObjectRefRequest) ApiAnythingNestedOneOfObjectRefRequest {
	r.anythingNestedOneOfObjectRefRequest = &anythingNestedOneOfObjectRefRequest
	return r
}

func (r ApiAnythingNestedOneOfObjectRefRequest) Execute() (*http.Response, error) {
	return r.ApiService.AnythingNestedOneOfObjectRefExecute(r)
}

/*
AnythingNestedOneOfObjectRef nested oneOf object with $ref pointers

description

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAnythingNestedOneOfObjectRefRequest
*/
func (a *PetsAPIService) AnythingNestedOneOfObjectRef(ctx context.Context) ApiAnythingNestedOneOfObjectRefRequest {
	return ApiAnythingNestedOneOfObjectRefRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *PetsAPIService) AnythingNestedOneOfObjectRefExecute(r ApiAnythingNestedOneOfObjectRefRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PetsAPIService.AnythingNestedOneOfObjectRef")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/anything/nested-one-of-object-ref"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.anythingNestedOneOfObjectRefRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAnythingNestedOneOfObjectWithNestedOneOfRequest struct {
	ctx context.Context
	ApiService *PetsAPIService
	anythingNestedOneOfObjectWithNestedOneOfRequest *AnythingNestedOneOfObjectWithNestedOneOfRequest
}

func (r ApiAnythingNestedOneOfObjectWithNestedOneOfRequest) AnythingNestedOneOfObjectWithNestedOneOfRequest(anythingNestedOneOfObjectWithNestedOneOfRequest AnythingNestedOneOfObjectWithNestedOneOfRequest) ApiAnythingNestedOneOfObjectWithNestedOneOfRequest {
	r.anythingNestedOneOfObjectWithNestedOneOfRequest = &anythingNestedOneOfObjectWithNestedOneOfRequest
	return r
}

func (r ApiAnythingNestedOneOfObjectWithNestedOneOfRequest) Execute() (*http.Response, error) {
	return r.ApiService.AnythingNestedOneOfObjectWithNestedOneOfExecute(r)
}

/*
AnythingNestedOneOfObjectWithNestedOneOf Method for AnythingNestedOneOfObjectWithNestedOneOf

description

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAnythingNestedOneOfObjectWithNestedOneOfRequest
*/
func (a *PetsAPIService) AnythingNestedOneOfObjectWithNestedOneOf(ctx context.Context) ApiAnythingNestedOneOfObjectWithNestedOneOfRequest {
	return ApiAnythingNestedOneOfObjectWithNestedOneOfRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *PetsAPIService) AnythingNestedOneOfObjectWithNestedOneOfExecute(r ApiAnythingNestedOneOfObjectWithNestedOneOfRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PetsAPIService.AnythingNestedOneOfObjectWithNestedOneOf")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/anything/nested-one-of-object-with-nested-one-of"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.anythingNestedOneOfObjectWithNestedOneOfRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAnythingNestedOneOfRefRequest struct {
	ctx context.Context
	ApiService *PetsAPIService
	anythingNestedOneOfRefRequest *AnythingNestedOneOfRefRequest
}

func (r ApiAnythingNestedOneOfRefRequest) AnythingNestedOneOfRefRequest(anythingNestedOneOfRefRequest AnythingNestedOneOfRefRequest) ApiAnythingNestedOneOfRefRequest {
	r.anythingNestedOneOfRefRequest = &anythingNestedOneOfRefRequest
	return r
}

func (r ApiAnythingNestedOneOfRefRequest) Execute() (*http.Response, error) {
	return r.ApiService.AnythingNestedOneOfRefExecute(r)
}

/*
AnythingNestedOneOfRef Method for AnythingNestedOneOfRef

description

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAnythingNestedOneOfRefRequest
*/
func (a *PetsAPIService) AnythingNestedOneOfRef(ctx context.Context) ApiAnythingNestedOneOfRefRequest {
	return ApiAnythingNestedOneOfRefRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *PetsAPIService) AnythingNestedOneOfRefExecute(r ApiAnythingNestedOneOfRefRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PetsAPIService.AnythingNestedOneOfRef")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/anything/nested-one-of-ref"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.anythingNestedOneOfRefRequest == nil {
		return nil, reportError("anythingNestedOneOfRefRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.anythingNestedOneOfRefRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAnythingOneOfObjectRequest struct {
	ctx context.Context
	ApiService *PetsAPIService
	anythingOneOfObjectRequest *AnythingOneOfObjectRequest
}

func (r ApiAnythingOneOfObjectRequest) AnythingOneOfObjectRequest(anythingOneOfObjectRequest AnythingOneOfObjectRequest) ApiAnythingOneOfObjectRequest {
	r.anythingOneOfObjectRequest = &anythingOneOfObjectRequest
	return r
}

func (r ApiAnythingOneOfObjectRequest) Execute() (*http.Response, error) {
	return r.ApiService.AnythingOneOfObjectExecute(r)
}

/*
AnythingOneOfObject oneOf object

description

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAnythingOneOfObjectRequest
*/
func (a *PetsAPIService) AnythingOneOfObject(ctx context.Context) ApiAnythingOneOfObjectRequest {
	return ApiAnythingOneOfObjectRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *PetsAPIService) AnythingOneOfObjectExecute(r ApiAnythingOneOfObjectRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PetsAPIService.AnythingOneOfObject")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/anything/one-of-object"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.anythingOneOfObjectRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAnythingOneOfObjectRefRequest struct {
	ctx context.Context
	ApiService *PetsAPIService
	anythingOneOfObjectRefRequest *AnythingOneOfObjectRefRequest
}

func (r ApiAnythingOneOfObjectRefRequest) AnythingOneOfObjectRefRequest(anythingOneOfObjectRefRequest AnythingOneOfObjectRefRequest) ApiAnythingOneOfObjectRefRequest {
	r.anythingOneOfObjectRefRequest = &anythingOneOfObjectRefRequest
	return r
}

func (r ApiAnythingOneOfObjectRefRequest) Execute() (*http.Response, error) {
	return r.ApiService.AnythingOneOfObjectRefExecute(r)
}

/*
AnythingOneOfObjectRef oneOf object with $ref pointers

description

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAnythingOneOfObjectRefRequest
*/
func (a *PetsAPIService) AnythingOneOfObjectRef(ctx context.Context) ApiAnythingOneOfObjectRefRequest {
	return ApiAnythingOneOfObjectRefRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *PetsAPIService) AnythingOneOfObjectRefExecute(r ApiAnythingOneOfObjectRefRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PetsAPIService.AnythingOneOfObjectRef")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/anything/one-of-object-ref"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.anythingOneOfObjectRefRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAnythingOneOfPrimitiveRequest struct {
	ctx context.Context
	ApiService *PetsAPIService
	anythingOneOfPrimitiveRequest *AnythingOneOfPrimitiveRequest
}

func (r ApiAnythingOneOfPrimitiveRequest) AnythingOneOfPrimitiveRequest(anythingOneOfPrimitiveRequest AnythingOneOfPrimitiveRequest) ApiAnythingOneOfPrimitiveRequest {
	r.anythingOneOfPrimitiveRequest = &anythingOneOfPrimitiveRequest
	return r
}

func (r ApiAnythingOneOfPrimitiveRequest) Execute() (*http.Response, error) {
	return r.ApiService.AnythingOneOfPrimitiveExecute(r)
}

/*
AnythingOneOfPrimitive oneOf primitive

description

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAnythingOneOfPrimitiveRequest
*/
func (a *PetsAPIService) AnythingOneOfPrimitive(ctx context.Context) ApiAnythingOneOfPrimitiveRequest {
	return ApiAnythingOneOfPrimitiveRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *PetsAPIService) AnythingOneOfPrimitiveExecute(r ApiAnythingOneOfPrimitiveRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PetsAPIService.AnythingOneOfPrimitive")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/anything/one-of-primitive"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.anythingOneOfPrimitiveRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetPetsRequest struct {
	ctx context.Context
	ApiService *PetsAPIService
	getPetsRequest *GetPetsRequest
}

func (r ApiGetPetsRequest) GetPetsRequest(getPetsRequest GetPetsRequest) ApiGetPetsRequest {
	r.getPetsRequest = &getPetsRequest
	return r
}

func (r ApiGetPetsRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetPetsExecute(r)
}

/*
GetPets oneOf request with a nested allOf

oneOf request with a nested allOf

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetPetsRequest
*/
func (a *PetsAPIService) GetPets(ctx context.Context) ApiGetPetsRequest {
	return ApiGetPetsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *PetsAPIService) GetPetsExecute(r ApiGetPetsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PetsAPIService.GetPets")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/pets"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.getPetsRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiOneOfComplexRequest struct {
	ctx context.Context
	ApiService *PetsAPIService
	oneOfComplexRequest *OneOfComplexRequest
}

func (r ApiOneOfComplexRequest) OneOfComplexRequest(oneOfComplexRequest OneOfComplexRequest) ApiOneOfComplexRequest {
	r.oneOfComplexRequest = &oneOfComplexRequest
	return r
}

func (r ApiOneOfComplexRequest) Execute() (*http.Response, error) {
	return r.ApiService.OneOfComplexExecute(r)
}

/*
OneOfComplex oneOf object with a complex schema

description

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiOneOfComplexRequest
*/
func (a *PetsAPIService) OneOfComplex(ctx context.Context) ApiOneOfComplexRequest {
	return ApiOneOfComplexRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *PetsAPIService) OneOfComplexExecute(r ApiOneOfComplexRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PetsAPIService.OneOfComplex")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/one-of-complex"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.oneOfComplexRequest == nil {
		return nil, reportError("oneOfComplexRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.oneOfComplexRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiOneOfWithTypeRequest struct {
	ctx context.Context
	ApiService *PetsAPIService
	oneOfWithTypeRequest *OneOfWithTypeRequest
}

func (r ApiOneOfWithTypeRequest) OneOfWithTypeRequest(oneOfWithTypeRequest OneOfWithTypeRequest) ApiOneOfWithTypeRequest {
	r.oneOfWithTypeRequest = &oneOfWithTypeRequest
	return r
}

func (r ApiOneOfWithTypeRequest) Execute() (*http.Response, error) {
	return r.ApiService.OneOfWithTypeExecute(r)
}

/*
OneOfWithType One Of With Type

OneOf's with a top level type parameter should not render that type outside of their options

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiOneOfWithTypeRequest
*/
func (a *PetsAPIService) OneOfWithType(ctx context.Context) ApiOneOfWithTypeRequest {
	return ApiOneOfWithTypeRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *PetsAPIService) OneOfWithTypeExecute(r ApiOneOfWithTypeRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PetsAPIService.OneOfWithType")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/one-of-with-type"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.oneOfWithTypeRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
